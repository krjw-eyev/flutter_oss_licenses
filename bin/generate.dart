import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

String? guessPubCacheDir() {
  var pubCache = Platform.environment['PUB_CACHE'];
  if (pubCache != null && Directory(pubCache).existsSync()) return pubCache;

  if (Platform.isWindows) {
    final appData = Platform.environment['APPDATA'];
    if (appData != null) {
      pubCache = path.join(appData, 'Pub', 'Cache');
      if (Directory(pubCache).existsSync()) return pubCache;
    }
    final localAppData = Platform.environment['LOCALAPPDATA'];
    if (localAppData != null) {
      pubCache = path.join(localAppData, 'Pub', 'Cache');
      if (Directory(pubCache).existsSync()) return pubCache;
    }
  }

  final homeDir = Platform.environment['HOME'] ?? Platform.environment['USERPROFILE'];
  if (homeDir != null) {
    return path.join(homeDir, '.pub-cache');
  }
  return null;
}

final flutterDir = Platform.environment['FLUTTER_ROOT'];
final pubCacheDirPath = guessPubCacheDir();

main(List<String> args) async {
  try {
    if (flutterDir == null) {
      print('FLUTTER_ROOT is not set.');
      return 1;
    } else if (pubCacheDirPath == null) {
      print('Could not determine PUB_CACHE directory.');
      return 2;
    } else if (args.length == 1 && (args[0] == '--help' || args[0] == '-h')) {
      print('Usage: generate.dart [OUTPUT_FILE_PATH [PROJECT_ROOT]]');
      return 3;
    }

    final projectRoot = args.length >= 2 ? args[1] : await findProjectRoot();
    final outputFilePath = args.length >= 1 ? args[0] : path.join(projectRoot, 'lib', 'oss_licenses.dart');
    final licenses = await generateLicenseFile(projectRoot: projectRoot);

    final dartCode = '''// cSpell:disable
// ignore_for_file: prefer_single_quotes

/// This code was generated by flutter_oss_licenses
/// https://pub.dev/packages/flutter_oss_licenses
final ossLicenses = <String, dynamic>''' +
        jsonEncode(licenses) +
        ';';

    await File(outputFilePath).writeAsString(dartCode);
    return 0;
  } catch (e, s) {
    print('$e: $s');
    return 4;
  }
}

Future<Map<String, dynamic>> generateLicenseFile({required String projectRoot}) async {
  final pubspec = loadYaml(await File(path.join(projectRoot, 'pubspec.lock')).readAsString());
  final packages = pubspec['packages'] as Map;

  final json = <String, dynamic>{};

  for (String name in packages.keys) {
    final package = await Package.fromMap(name, packages[name]);
    if (package == null || package.name == null) {
      continue;
    }

    json[name] = {
      'name': package.name,
      'description': package.description,
      'homepage': package.homepage,
      'authors': package.authors,
      'version': package.version,
      'license': package.license,
      'isMarkdown': package.isMarkdown,
      'isSdk': package.isSdk,
      'isDirectDependency': package.isDirectDependency
    };
  }
  return json;
}

Future<String> loadLicense({String? name, required String licenseFilePath, String? defaultLicenseText}) async {
  String? license = defaultLicenseText;
  try {
    license = await File(licenseFilePath).readAsString();
  } catch (e) {
    // ignore
  }
  return '//\n// $name\n//\n\'$name\': \'\'\'$license\'\'\',\n';
}

class Package {
  final Directory? directory;
  final Map? packageYaml;
  final String? name;
  final String? description;
  final String? homepage;
  final List<String>? authors;
  final String? version;
  final String? license;
  final bool? isMarkdown;
  final bool? isSdk;
  final bool? isDirectDependency;

  Package(
      {this.directory,
      this.packageYaml,
      this.name,
      this.description,
      this.homepage,
      this.authors,
      this.version,
      this.license,
      this.isMarkdown,
      this.isSdk,
      this.isDirectDependency});

  static Future<Package?> fromMap(String outerName, Map packageJson) async {
    Directory directory;
    bool isSdk = false;
    final source = packageJson['source'];
    final descs = packageJson['description'];
    if (source == 'hosted') {
      final host = removePrefix(descs['url']);
      final name = descs['name'];
      final version = packageJson['version'];
      directory = Directory(path.join(pubCacheDirPath!, 'hosted/$host/$name-$version'));
    } else if (source == 'git') {
      final repo = gitRepoName(descs['url']);
      final commit = descs['resolved-ref'];
      directory = Directory(path.join(pubCacheDirPath!, 'git/$repo-$commit'));
    } else if (source == 'sdk') {
      directory = Directory(path.join(flutterDir!, 'packages', outerName));
      isSdk = true;
    } else {
      return null;
    }
    final isDirectDependency = packageJson['dependency'] == "direct main";

    String? license;
    bool isMarkdown = false;
    if (outerName == 'flutter') {
      license = await File(path.join(flutterDir!, 'LICENSE')).readAsString();
    } else {
      String licensePath = path.join(directory.path, 'LICENSE');
      try {
        license = await File(licensePath).readAsString();
      } catch (e) {
        try {
          license = await File(licensePath + '.md').readAsString();
          isMarkdown = true;
        } catch (e) {}
      }
    }

    if (license == null || license == '') {
      return null;
    }

    dynamic yaml;
    try {
      yaml = loadYaml(await File(path.join(directory.path, 'pubspec.yaml')).readAsString());
    } catch (e) {
      // yaml may not be there
      yaml = {};
    }

    if (yaml['description'] == null) {
      return null;
    }

    String? version = yaml['version'];
    if (outerName == 'flutter') {
      version = await File(path.join(flutterDir!, 'version')).readAsString();
    }
    if (version == null) {
      return null;
    }

    return Package(
        directory: directory,
        packageYaml: yaml,
        name: yaml['name'],
        description: yaml['description'],
        homepage: yaml['homepage'],
        authors: yaml['authors']?.cast<String>()?.toList() ?? (yaml['author'] != null ? [yaml['author']] : []),
        version: version.trim(),
        license: license.trim().replaceAll('\r\n', '\n'),
        isMarkdown: isMarkdown,
        isSdk: isSdk,
        isDirectDependency: isDirectDependency);
  }
}

String removePrefix(String url) {
  if (url.startsWith('https://')) return url.substring(8);
  if (url.startsWith('http://')) return url.substring(7); // are there any?
  return url;
}

String gitRepoName(String url) {
  final name = url.substring(url.lastIndexOf('/') + 1);
  return name.endsWith('.git') ? name.substring(0, name.length - 4) : name;
}

Future<String> findProjectRoot({Directory? from}) async {
  from = from ?? Directory.current;
  if (await File(path.join(from.path, 'pubspec.yaml')).exists()) {
    return from.path;
  }
  return findProjectRoot(from: from.parent);
}
